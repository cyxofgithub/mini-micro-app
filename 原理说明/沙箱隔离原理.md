# 沙箱隔离原理

## 概述

通过 Proxy 代理和 with 语句实现 JavaScript 作用域隔离，防止子应用的代码污染全局环境。

## 实现机制

### 1. Proxy 代理 window 对象

创建代理对象拦截属性访问和设置：

```11:53:src/sandbox.js
        this.proxyWindow = new Proxy(this.microWindow, {
            // 取值
            get: (target, key) => {
                // 优先从代理对象上取值
                if (Reflect.has(target, key)) {
                    return Reflect.get(target, key)
                }

                // 否则兜底到window对象上取值
                const rawValue = Reflect.get(window, key)

                // 如果兜底的值为函数，则需要绑定window对象，如：console、alert等
                if (typeof rawValue === 'function') {
                    const valueStr = rawValue.toString()
                    // 排除构造函数
                    if (!/^function\s+[A-Z]/.test(valueStr) && !/^class\s+/.test(valueStr)) {
                        return rawValue.bind(window)
                    }
                }

                // 其它情况直接返回
                return rawValue
            },
            // 设置变量
            set: (target, key, value) => {
                // 沙箱只有在运行时可以设置变量
                if (this.active) {
                    Reflect.set(target, key, value)

                    // 记录添加的变量，用于后续清空操作
                    this.injectedKeys.add(key)
                }

                return true
            },
            deleteProperty: (target, key) => {
                // 当前key存在于代理对象上时才满足删除条件
                if (target.hasOwnProperty(key)) {
                    return Reflect.deleteProperty(target, key)
                }
                return true
            },
        })
```

**关键点：**

-   `get`：优先从 `microWindow` 取值，否则从全局 `window` 取值
-   函数需要绑定 `window` 上下文（如 `console`、`alert`），但排除构造函数
-   `set`：只在沙箱激活时允许设置变量，并记录到 `injectedKeys`
-   `deleteProperty`：只能删除代理对象自身的属性

### 2. with 语句改变作用域

使用 `with` 语句将代码执行在代理对象的作用域中：

```82:88:src/sandbox.js
    bindScope(code) {
        window.proxyWindow = this.proxyWindow
        // 'with'语句将某个对象添加到作用域链的顶部，如果在 statement 中有某个未使用命名空间的变量，跟作用域链中的某个属性同名，则这个变量将指向这个属性值。
        // 如果沒有同名的属性，则将拋出ReferenceError异常。
        return `;(function(window, self){with(window){;${code}\n}}).call(window.proxyWindow, window.proxyWindow, window.proxyWindow);`
    }
```

**关键点：**

-   将代码包装在立即执行函数中
-   使用 `with(window)` 将代理对象添加到作用域链顶部
-   代码中的 `window`、`self` 都指向 `proxyWindow`
-   未命名空间的变量会优先从 `proxyWindow` 查找

### 3. 注入通信对象

在沙箱中注入 `microApp` 通信对象：

```7:10:src/sandbox.js
    constructor(appName) {
        // 创建数据通信对象
        this.microWindow.microApp = new EventCenterForMicroApp(appName)
        this.releaseEffect = effect(this.microWindow)
```

**关键点：**

-   子应用通过 `window.microApp` 访问通信 API
-   通信对象绑定到应用名称，实现隔离

### 4. 全局事件管理

重写 `addEventListener` 和 `removeEventListener` 来管理全局事件：

```100:127:src/sandbox.js
function effect(microWindow) {
    // 使用Map记录全局事件
    const eventListenerMap = new Map()

    // 重写addEventListener
    microWindow.addEventListener = function (type, listener, options) {
        const listenerList = eventListenerMap.get(type)
        // 当前事件非第一次监听，则添加缓存
        if (listenerList) {
            listenerList.add(listener)
        } else {
            // 当前事件第一次监听，则初始化数据
            eventListenerMap.set(type, new Set([listener]))
        }
        // 执行原生监听函数
        return rawWindowAddEventListener.call(window, type, listener, options)
    }

    // 重写removeEventListener
    microWindow.removeEventListener = function (type, listener, options) {
        const listenerList = eventListenerMap.get(type)
        // 从缓存中删除监听函数
        if (listenerList?.size && listenerList.has(listener)) {
            listenerList.delete(listener)
        }
        // 执行原生解绑函数
        return rawWindowRemoveEventListener.call(window, type, listener, options)
    }
```

**关键点：**

-   记录所有通过沙箱添加的事件监听器
-   卸载时统一清理，防止内存泄漏

### 5. 沙箱生命周期

**启动：**

```56:61:src/sandbox.js
    start() {
        if (!this.active) {
            this.active = true
        }
    }
```

**停止和清理：**

```63:80:src/sandbox.js
    stop() {
        if (this.active) {
            this.active = false

            // 清空变量
            this.injectedKeys.forEach((key) => {
                Reflect.deleteProperty(this.microWindow, key)
            })
            this.injectedKeys.clear()

            // 卸载全局事件
            this.releaseEffect()

            // 清空所有绑定函数
             this.microWindow.microApp.clearDataListener()
        }
    }
```

**关键点：**

-   启动时设置 `active = true`，允许设置变量
-   停止时清空所有注入的变量和事件监听器
-   清空通信监听函数

## 使用流程

1. **创建沙箱**：在应用实例化时创建 `Sandbox` 实例
2. **启动沙箱**：在 `mount` 时调用 `sandbox.start()`
3. **执行代码**：通过 `sandbox.bindScope()` 包装代码后执行
4. **停止沙箱**：在 `unmount` 时调用 `sandbox.stop()` 清理

```18:18:src/app.js
        this.sandbox = new Sandbox(name) // 创建沙箱
```

```58:65:src/app.js
        // 启动沙箱
        this.sandbox.start()

        // 执行js
        this.source.scripts.forEach((info) => {
            // (0, eval)(info.code)
            (0, eval)(this.sandbox.bindScope(info.code))
        })
```

```80:81:src/app.js
    // 关闭沙箱
    this.sandbox.stop()
```

## 沙箱隔离总结

1. **核心机制**：Proxy 代理 + with 语句
2. **隔离范围**：全局变量、事件监听器、通信对象
3. **生命周期**：创建 → 启动 → 执行 → 停止清理
4. **关键特性**：变量隔离、事件管理、通信注入
