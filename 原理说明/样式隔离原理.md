# 样式隔离原理

## 概述

通过为 CSS 选择器添加 `micro-app[name=xxx]` 前缀，限制样式作用域，防止子应用样式影响基座和其他子应用。

## 实现机制

### 1. 样式处理入口

在提取资源时处理 `<style>` 标签和远程 CSS：

```91:94:src/source.js
        } else if (dom instanceof HTMLStyleElement) {
            // 进行样式隔离
            scopedCSS(dom, app.name)
        }
```

```115:119:src/source.js
            // 拿到css资源后放入style元素并插入到micro-app-head中
            const link2Style = document.createElement('style')
            link2Style.textContent = code
            scopedCSS(link2Style, app.name)
            microAppHead.appendChild(link2Style)
```

**关键点：**

-   内联 `<style>` 标签直接处理
-   远程 CSS 转为 `<style>` 标签后处理
-   处理后再插入到 DOM

### 2. 核心处理函数

`scopedCSS` 函数处理样式隔离：

```8:41:src/scopedcss.js
export default function scopedCSS(styleElement, appName) {
    // 前缀
    const prefix = `micro-app[name=${appName}]`

    // 初始化时创建模版标签
    if (!templateStyle) {
        templateStyle = document.createElement('style')
        document.body.appendChild(templateStyle)
        // 设置样式表无效，防止对应用造成影响
        templateStyle.sheet.disabled = true
    }

    if (styleElement.textContent) {
        // 将元素的内容赋值给模版元素
        templateStyle.textContent = styleElement.textContent
        // 格式化规则，并将格式化后的规则赋值给style元素
        styleElement.textContent = scopedRule(Array.from(templateStyle.sheet?.cssRules ?? []), prefix)
        // 清空模版style内容
        templateStyle.textContent = ''
    } else {
        // 监听动态添加内容的style元素
        const observer = new MutationObserver(function () {
            // 断开监听
            observer.disconnect()
            // 格式化规则，并将格式化后的规则赋值给style元素
            styleElement.textContent = scopedRule(Array.from(styleElement.sheet?.cssRules ?? []), prefix)
        })

        // 监听style元素的内容是否变化
        observer.observe(styleElement, {
            childList: true
        })
    }
}
```

**关键点：**

-   创建模板 `<style>` 标签用于解析 CSS 规则
-   通过 `sheet.cssRules` 获取 CSSRule 对象
-   使用 `MutationObserver` 监听动态添加的样式

### 3. CSS 规则处理

遍历所有 CSS 规则并分类处理：

```48:69:src/scopedcss.js
function scopedRule(rules, prefix) {
    let result = ''
    // 遍历rules，处理每一条规则
    for (const rule of rules) {
        switch (rule.type) {
            case 1: // STYLE_RULE
                result += scopedStyleRule(rule, prefix)
                break
            case 4: // MEDIA_RULE
                result += scopedPackRule(rule, prefix, 'media')
                break
            case 12: // SUPPORTS_RULE
                result += scopedPackRule(rule, prefix, 'supports')
                break
            default:
                result += rule.cssText
                break
        }
    }

    return result
}
```

**关键点：**

-   `STYLE_RULE`（1）：普通样式规则
-   `MEDIA_RULE`（4）：`@media` 查询规则
-   `SUPPORTS_RULE`（12）：`@supports` 规则
-   其他规则直接使用原始 `cssText`

### 4. 嵌套规则处理

递归处理 `@media` 和 `@supports` 内部的规则：

```71:76:src/scopedcss.js
function scopedPackRule(rule, prefix, packName) {
    // 递归执行scopedRule，处理media 和 supports内部规则
    const result = scopedRule(Array.from(rule.cssRules), prefix)
    return `@${packName} ${rule.conditionText} {${result}}`
}
```

**关键点：**

-   递归处理嵌套规则
-   保留 `@media` 和 `@supports` 的条件文本

### 5. 选择器作用域化

为核心逻辑，为选择器添加前缀：

```83:112:src/scopedcss.js
function scopedStyleRule(rule, prefix) {
    // 获取CSS规则对象的选择和内容
    const {
        selectorText,
        cssText
    } = rule

    // 处理顶层选择器，如 body，html 都转换为 micro-app[name=xxx]
    if (/^((html[\s>~,]+body)|(html|body|:root))$/.test(selectorText)) {
        return cssText.replace(/^((html[\s>~,]+body)|(html|body|:root))/, prefix)
    } else if (selectorText === '*') {
        // 选择器 * 替换为 micro-app[name=xxx] *
        return cssText.replace('*', `${prefix} *`)
    }

    const builtInRootSelectorRE = /(^|\s+)((html[\s>~]+body)|(html|body|:root))(?=[\s>~]+|$)/

    // 匹配查询选择器
    return cssText.replace(/^[\s\S]+{/, (selectors) => {
        return selectors.replace(/(^|,)([^,]+)/g, (all, $1, $2) => {
            // 如果含有顶层选择器，需要单独处理
            if (builtInRootSelectorRE.test($2)) {
                // body[name=xx]|body.xx|body#xx 等都不需要转换
                return all.replace(builtInRootSelectorRE, prefix)
            }
            // 在选择器前加上前缀
            return `${$1} ${prefix} ${$2.replace(/^\s*/, '')}`
        })
    })
}
```

**处理逻辑：**

1. **顶层选择器替换**：

    - `html`、`body`、`:root` → `micro-app[name=xxx]`
    - `html > body` → `micro-app[name=xxx]`

2. **通配符处理**：

    - `*` → `micro-app[name=xxx] *`

3. **普通选择器**：

    - `.container` → `micro-app[name=xxx] .container`
    - `div, span` → `micro-app[name=xxx] div, micro-app[name=xxx] span`

4. **复合选择器**：
    - `body .container` → `micro-app[name=xxx] .container`
    - 保留 `body.class`、`body#id` 等不需要转换的情况

## 样式隔离总结

1. **核心机制**：为 CSS 选择器添加容器前缀
2. **处理时机**：提取资源时和插入 DOM 前
3. **处理范围**：普通规则、`@media`、`@supports`、动态样式
4. **前缀格式**：`micro-app[name=${appName}]`
5. **特殊处理**：顶层选择器替换、通配符处理、嵌套规则递归
