# 通信原理

## 概述

通过发布订阅模式和 CustomEvent 实现基座应用与子应用之间的双向数据通信。

## 实现机制

### 1. 发布订阅中心

使用 `EventCenter` 类管理所有通信事件：

```3:48:src/data.js
class EventCenter {
    // 缓存数据和绑定函数
    eventList = new Map()
    /**
     * 绑定监听函数
     * @param name 事件名称
     * @param f 绑定函数
     */
    on(name, f) {
        let eventInfo = this.eventList.get(name)
        // 如果没有缓存，则初始化
        if (!eventInfo) {
            eventInfo = {
                data: {},
                callbacks: new Set(),
            }
            // 放入缓存
            this.eventList.set(name, eventInfo)
        }

        // 记录绑定函数
        eventInfo.callbacks.add(f)
    }

    // 解除绑定
    off(name, f) {
        const eventInfo = this.eventList.get(name)
        // eventInfo存在且f为函数则卸载指定函数
        if (eventInfo && typeof f === 'function') {
            eventInfo.callbacks.delete(f)
        }
    }

    // 发送数据
    dispatch(name, data) {
        const eventInfo = this.eventList.get(name)
        // 当数据不相等时才更新
        if (eventInfo && eventInfo.data !== data) {
            eventInfo.data = data
            // 遍历执行所有绑定函数
            for (const f of eventInfo.callbacks) {
                f(data)
            }
        }
    }
}
```

**关键点：**

-   使用 `Map` 存储事件信息
-   每个事件包含 `data` 和 `callbacks`（Set 集合）
-   数据变化时才触发回调

### 2. 事件名称格式化

格式化事件名称，区分基座和子应用：

```53:61:src/data.js
/**
 * 格式化事件名称，保证基座应用和子应用的绑定通信
 * @param appName 应用名称
 * @param fromBaseApp 是否从基座应用发送数据
 */
function formatEventName(appName, fromBaseApp) {
    if (typeof appName !== 'string' || !appName) return ''
    return fromBaseApp ? `__from_base_app_${appName}__` : `__from_micro_app_${appName}__`
}
```

**关键点：**

-   基座 → 子应用：`__from_base_app_${appName}__`
-   子应用 → 基座：`__from_micro_app_${appName}__`
-   通过命名区分通信方向

### 3. 基座应用通信 API

基座应用通过 `EventCenterForBaseApp` 发送数据：

```64:81:src/data.js
export class EventCenterForBaseApp {
    /**
     * 向指定子应用发送数据
     * @param appName 子应用名称
     * @param data 对象数据
     */
    setData(appName, data) {
        eventCenter.dispatch(formatEventName(appName, true), data)
    }

    /**
     * 清空某个应用的监听函数
     * @param appName 子应用名称
     */
    clearDataListener(appName) {
        eventCenter.off(formatEventName(appName, false))
    }
}
```

**关键点：**

-   `setData`：向指定子应用发送数据
-   `clearDataListener`：清空子应用的监听函数

### 4. 属性传递机制

重写 `setAttribute` 拦截 `data` 属性设置：

```6:27:src/index.js
// 记录原生方法
const rawSetAttribute = Element.prototype.setAttribute

// 重写setAttribute
Element.prototype.setAttribute = function setAttribute (key, value) {
  // 目标为micro-app标签且属性名称为data时进行处理
  if (/^micro-app/i.test(this.tagName) && key === 'data') {
    if (toString.call(value) === '[object Object]') {
      // 克隆一个新的对象
      const cloneValue = {}
      Object.getOwnPropertyNames(value).forEach((propertyKey) => {
        // 过滤vue框架注入的数据
        if (!(typeof propertyKey === 'string' && propertyKey.indexOf('__') === 0)) {
          cloneValue[propertyKey] = value[propertyKey]
        }
      })
      // 发送数据
      BaseAppData.setData(this.getAttribute('name'), cloneValue)
    }
  } else {
    rawSetAttribute.call(this, key, value)
  }
}
```

**关键点：**

-   拦截 `micro-app` 元素的 `data` 属性设置
-   过滤框架注入的属性（以 `__` 开头）
-   克隆对象后调用 `setData` 发送数据

### 5. 子应用通信 API

子应用通过 `EventCenterForMicroApp` 进行通信：

```84:131:src/data.js
export class EventCenterForMicroApp {
    constructor(appName) {
        this.appName = appName
    }

    /**
     * 监听基座应用发送的数据
     * @param cb 绑定函数
     */
    addDataListener(cb) {
        eventCenter.on(formatEventName(this.appName, true), cb)
    }

    /**
     * 解除监听函数
     * @param cb 绑定函数
     */
    removeDataListener(cb) {
        if (typeof cb === 'function') {
            eventCenter.off(formatEventName(this.appName, true), cb)
        }
    }

    /**
     * 向基座应用发送数据
     * @param data 对象数据
     */
    dispatch(data) {
        const app = appInstanceMap.get(this.appName)
        if (app?.container) {
            // 子应用以自定义事件的形式发送数据
            const event = new CustomEvent('datachange', {
                detail: {
                    data,
                }
            })

            app.container.dispatchEvent(event)
        }
    }

    /**
     * 清空当前子应用绑定的所有监听函数
     */
    clearDataListener() {
        eventCenter.off(formatEventName(this.appName, true))
    }
}
```

**关键点：**

-   `addDataListener`：监听基座发送的数据
-   `dispatch`：通过 `CustomEvent` 向基座发送数据
-   `removeDataListener`：移除指定监听函数
-   `clearDataListener`：清空所有监听函数

### 6. 沙箱中注入通信对象

在沙箱创建时注入 `microApp` 对象：

```7:9:src/sandbox.js
    constructor(appName) {
        // 创建数据通信对象
        this.microWindow.microApp = new EventCenterForMicroApp(appName)
```

子应用通过 `window.microApp` 访问通信 API。

## 通信流程

### 基座 → 子应用

1. 基座设置 `<micro-app data={...}>` 属性
2. `setAttribute` 被拦截，调用 `BaseAppData.setData()`
3. `EventCenter` 触发 `__from_base_app_${appName}__` 事件
4. 子应用通过 `window.microApp.addDataListener()` 接收数据

### 子应用 → 基座

1. 子应用调用 `window.microApp.dispatch(data)`
2. 创建 `CustomEvent('datachange')` 事件
3. 在 `micro-app` 容器元素上派发事件
4. 基座通过 `addEventListener('datachange')` 接收数据

## 通信原理总结

1. **核心机制**：发布订阅模式 + CustomEvent
2. **通信方向**：基座 ↔ 子应用（双向）
3. **基座方式**：通过属性传递，自动触发通信
4. **子应用方式**：通过 `window.microApp` API
5. **事件命名**：格式化事件名称区分通信方向
