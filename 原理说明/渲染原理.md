# 微前端渲染原理

## 概述

微前端框架通过自定义元素、HTML 解析、资源提取和沙箱隔离等技术，实现了子应用的独立加载和渲染。

## 渲染流程

### 1. 自定义元素注册

使用 Web Components 技术注册 `micro-app` 自定义元素：

```javascript
// 当 DOM 中出现 <micro-app> 标签时触发
connectedCallback() {
  // 创建微应用实例
  const app = new CreateApp({
    name: this.name,
    url: this.url,
    container: this,
  })

  // 记入缓存，用于后续功能
  appInstanceMap.set(this.name, app)
}
```

**关键点：**

-   通过 `window.customElements.define('micro-app', MyElement)` 注册自定义元素
-   当 `<micro-app>` 元素被插入 DOM 时，自动触发 `connectedCallback`
-   创建应用实例并缓存到 `appInstanceMap`
-   监听 `name` 和 `url` 属性的变化

### 2. HTML 加载与解析

从子应用 URL 获取 HTML 并进行预处理：

```javascript
fetchSource(app.url).then((html) => {
    // 替换 head 标签为 micro-app-head
    html = html.replace(/<head[^>]*>[\s\S]*?<\/head>/i, (match) => {
        return match
            .replace(/<head/i, "<micro-app-head")
            .replace(/<\/head>/i, "</micro-app-head>");
    });

    // 替换 body 标签为 micro-app-body
    html = html.replace(/<body[^>]*>[\s\S]*?<\/body>/i, (match) => {
        return match
            .replace(/<body/i, "<micro-app-body")
            .replace(/<\/body>/i, "</micro-app-body>");
    });

    // 将 HTML 字符串转化为 DOM 结构
    const htmlDom = document.createElement("div");
    htmlDom.innerHTML = html;
});
```

**关键点：**

-   将 `<head>` 替换为 `<micro-app-head>`，避免与基座应用的 head 冲突（因为 web 页面只允许有一个 head 标签）
-   将 `<body>` 替换为 `<micro-app-body>`，防止标签重复导致的问题
-   将 HTML 字符串解析为 DOM 对象，便于后续操作

### 3. 静态资源提取

递归遍历 DOM，提取 CSS 和 JS 资源：

```javascript
function extractSourceDom(parent, app) {
    const children = Array.from(parent.children);

    // 递归处理每个子元素
    children.length &&
        children.forEach((child) => {
            extractSourceDom(child, app);
        });

    for (const dom of children) {
        if (dom instanceof HTMLLinkElement) {
            // 提取 CSS 地址
            const href = dom.getAttribute("href");
            if (dom.getAttribute("rel") === "stylesheet" && href) {
                app.source.links.set(href, { code: "" });
            }
            parent.removeChild(dom); // 从 DOM 中移除
        } else if (dom instanceof HTMLScriptElement) {
            const src = dom.getAttribute("src");
            if (src) {
                // 远程 script
                app.source.scripts.set(src, {
                    code: "",
                    isExternal: true,
                });
            } else if (dom.textContent) {
                // 内联 script
                const nonceStr = Math.random().toString(36).substr(2, 15);
                app.source.scripts.set(nonceStr, {
                    code: dom.textContent,
                    isExternal: false,
                });
            }
            parent.removeChild(dom); // 从 DOM 中移除
        } else if (dom instanceof HTMLStyleElement) {
            // 进行样式隔离（后续处理）
        }
    }
}
```

**关键点：**

-   递归遍历所有子元素，确保提取所有资源
-   提取所有 `<link rel="stylesheet">` 的 CSS 地址
-   提取所有 `<script>` 的 JS（区分远程和内联）
-   从 DOM 中移除这些标签，避免浏览器自动加载和执行
-   资源信息缓存到 `app.source.links` 和 `app.source.scripts`

### 4. 资源加载

并行加载 CSS 和 JS 资源：

**CSS 加载：**

```javascript
// 通过 fetch 请求所有 CSS 资源
const fetchLinkPromise = [];
for (const [url] of linkEntries) {
    fetchLinkPromise.push(fetchSource(url));
}

Promise.all(fetchLinkPromise).then((res) => {
    for (let i = 0; i < res.length; i++) {
        const code = res[i];
        // 将 CSS 代码放入 style 元素
        const link2Style = document.createElement("style");
        link2Style.textContent = code;
        microAppHead.appendChild(link2Style);

        // 缓存代码，再次渲染时可以从缓存中获取
        linkEntries[i][1].code = code;
    }
    app.onLoad(htmlDom);
});
```

**JS 加载：**

```javascript
// 通过 fetch 请求所有 JS 资源（内联 script 直接使用）
const fetchScriptPromise = [];
for (const [url, info] of scriptEntries) {
    // 如果是内联script，则不需要请求资源
    fetchScriptPromise.push(
        info.code ? Promise.resolve(info.code) : fetchSource(url)
    );
}

Promise.all(fetchScriptPromise).then((res) => {
    for (let i = 0; i < res.length; i++) {
        const code = res[i];
        // 缓存代码，等待执行
        scriptEntries[i][1].code = code;
    }
    app.onLoad(htmlDom);
});
```

**关键点：**

-   CSS 转为 `<style>` 标签插入到 `<micro-app-head>` 中
-   JS 代码缓存到 `app.source.scripts`，等待执行
-   使用 `Promise.all` 并行加载，提高性能
-   资源代码会被缓存，再次渲染时可直接使用
-   内联 script 不需要网络请求，直接使用已有代码

### 5. 等待资源加载完成

使用计数器机制确保 CSS 和 JS 都加载完成：

```javascript
onLoad(htmlDom) {
  this.loadCount = this.loadCount ? this.loadCount + 1 : 1
  // 第二次执行且组件未卸载时执行渲染
  if (this.loadCount === 2 && this.status !== 'unmount') {
    // 记录DOM结构用于后续操作
    this.source.html = htmlDom
    // 执行mount方法
    this.mount()
  }
}
```

**关键点：**

-   CSS 和 JS 加载完成后都会调用 `onLoad`
-   当 `loadCount === 2` 时，说明资源都已加载完成
-   只有资源全部加载完成后才会执行渲染
-   如果应用已卸载（`status === 'unmount'`），则不执行渲染

### 6. DOM 渲染与 JS 执行

挂载阶段进行 DOM 插入和 JS 执行：

```javascript
mount() {
  // 1. 克隆 DOM 节点
  const cloneHtml = this.source.html.cloneNode(true)

  // 2. 使用 DocumentFragment 优化性能
  // 文档片段存在于内存中，并不在DOM树中，所以将子元素插入到文档片段时不会引起页面回流
  const fragment = document.createDocumentFragment()
  Array.from(cloneHtml.childNodes).forEach((node) => {
    fragment.appendChild(node)
  })

  // 3. 将格式化后的DOM结构插入到容器中
  this.container.appendChild(fragment)

  // 4. 执行所有 JS 代码
  this.source.scripts.forEach((info) => {
    (0, eval)(info.code)
  })

  // 5. 标记应用为已渲染
  this.status = 'mounted'
}
```

**关键点：**

-   克隆 DOM 节点，避免修改原始结构
-   使用 `DocumentFragment` 批量插入，减少页面回流（reflow）
-   将格式化后的 DOM 插入到 `micro-app` 容器中
-   执行所有缓存的 JS 代码（在沙箱环境中执行，实现作用域隔离）
-   更新应用状态为 `mounted`

## 渲染原理总结

整个渲染流程可以概括为：

1. **元素注册**：通过 Web Components 监听 `<micro-app>` 元素插入
2. **HTML 解析**：获取并解析子应用 HTML，替换标签避免冲突
3. **资源提取**：递归提取 CSS/JS 资源，从 DOM 中移除
4. **并行加载**：使用 `Promise.all` 并行加载所有资源
5. **同步等待**：通过计数器机制确保资源加载完成
6. **渲染执行**：使用 `DocumentFragment` 插入 DOM，执行 JS 代码

## 性能优化

1. **DocumentFragment**：使用文档片段批量插入 DOM，减少回流（reflow）和重绘（repaint）
2. **资源缓存**：加载的资源会被缓存，再次渲染时可直接使用，提高性能
3. **并行加载**：CSS 和 JS 资源并行加载，提高加载速度
4. **DOM 克隆**：克隆 DOM 节点，避免修改原始结构，支持多次渲染

## 注意事项

1. **标签替换**：`<head>` 和 `<body>` 必须替换，避免与基座冲突
2. **资源移除**：提取资源后需要从 DOM 中移除，避免浏览器自动加载和执行
3. **执行顺序**：确保 CSS 和 JS 都加载完成后再执行渲染
4. **沙箱隔离**：JS 代码应在沙箱环境中执行，实现作用域隔离（详见沙箱隔离原理）
5. **状态管理**：应用状态包括 `created`、`loading`、`mounted`、`unmount`

## 卸载流程

当 `<micro-app>` 元素从 DOM 中移除时，会触发 `disconnectedCallback`：

```javascript
disconnectedCallback() {
  const app = appInstanceMap.get(this.name)
  // 如果有属性destory，则完全卸载应用包括缓存的文件
  // 默认情况下，子应用被卸载后会缓存静态资源，以便在重新渲染时获得更好的性能
  app.unmount(this.hasAttribute('destory'))
}
```

**关键点：**

-   默认情况下，卸载时会保留资源缓存，提高重新渲染性能
-   如果设置了 `destory` 属性，则完全销毁应用，包括删除缓存资源
